#!/usr/bin/env python

# This script extract features and write the anndata with new annotation to file

import argparse
import torch
import sys
from typing import List
from anndata import read_h5ad
from tissue_purifier.data import AnndataFolderDM
from tissue_purifier.models.ssl_models import *


def smart_bool(v):
    if isinstance(v, bool):
        return v
    if v.lower() in ('yes', 'true', 't', 'y', '1'):
        return True
    elif v.lower() in ('no', 'false', 'f', 'n', '0'):
        return False
    else:
        raise argparse.ArgumentTypeError('Boolean value expected.')


def parse_args(argv: List[str]) -> dict:
    """
    Read argv from command-line and produce a configuration dictionary.
    If the command-line arguments include

    If the command-line arguments include '--to_yaml my_yaml_file.yaml' the configuration dictionary is written to file.

    Args:
        argv: the parameter passed from the command line.

    Note:
        If argv includes '--config input.yaml' the parameters are read from file.
        The config.yaml parameters have priority over the CLI parameters.

    Note:
        If argv includes '--to_yaml output.yaml' the configuration dictionary is written to file.

    Note:
        Parameters which are missing from both argv and config.yaml will be set to their default values.

    Returns:
        config_dict: a dictionary with all the configuration parameters.
    """
    parser = argparse.ArgumentParser(add_help=False, conflict_handler='resolve')

    parser.add_argument("--anndata_in", type=str, required=True,
                        help="path to the anndata.h5ad to annotate")

    parser.add_argument("--anndata_out", type=str, required=True,
                        help="path to the anndata.h5ad which will be saved to disk. \
                             If it is equal to anndata_in the file will be overwritten.")

    # stuff related to ssl features
    parser.add_argument("--ckpt_in", type=str, required=True,
                        help="Path to the checkpoint file generated by the training script")
    parser.add_argument("--feature_key", type=str, required=True,
                        help="The computed features will be saves in anndata.obsm under this name.")
    parser.add_argument("--gpu_enabled", type=smart_bool, default=torch.cuda.is_available(),
                        help="Use gpu or not to compute the features.")
    parser.add_argument("--n_patches", type=int, default=1000,
                        help="Number of patches used to tile the sparse image")
    parser.add_argument("--strategy_patch_to_image", type=str, choices=['average', 'closest'],
                        default='average', help="How to combine overlapping patches to create an image-level feature")
    parser.add_argument("--strategy_image_to_spot", type=str, choices=['closest', 'bilinear'],
                        default='bilinear', help="How to interpolate from the image-level to spot-level features")
    parser.add_argument("--ssl_model", type=str, default=None,
                        choices=["barlow", "dino", "vae", "simclr"],
                        help="the Self Supervised Learning framework corresponding to the checkpoint. In most cases \
                        this parameter is not required and the ssl_model will be inferred from the checkpoint.")

    # if specified ncv_r is computed
    parser.add_argument("--ncv_r", type=float, nargs='*', default=None,
                        help="If specified the neighborhood composition vector with radius r is computed. \
                             If it is a list multiple ncv corresponding to all radius will be computed.")

    # if specified ncv_k is computed
    parser.add_argument("--ncv_k", type=int, nargs='*', default=None,
                        help="If specified the neighborhood composition vector with k neighbours is computed. \
                             If it is a list multiple ncv corresponding to all neighbours k will be computed.")

    # Add help at the very end
    parser = argparse.ArgumentParser(parents=[parser], add_help=True)

    # Process everything and check
    args = parser.parse_args(argv)

    if args.ncv_k is not None:
        for tmp in args.ncv_k:
            assert isinstance(tmp, int) and tmp >= 1, "ncv_k must be a positive integer. Received {0}".format(tmp)
    if args.ncv_r is not None:
        for tmp in args.ncv_r:
            assert tmp > 0, "ncv_r must be non-negative. Received {0}".format(tmp)

    return vars(args)


if __name__ == '__main__':
    config_dict_ = parse_args(sys.argv[1:])

    # load the pretrained model
    if config_dict_["ssl_model"] is None:
        # try to infer the ssl_model from the ckpt itself
        tmp = torch.load(config_dict_["ckpt_in"], map_location='cpu')
        ssl_model = tmp["hyper_parameters"]["ssl_model"]
    else:
        ssl_model = config_dict_["ssl_model"]

    if ssl_model == "barlow":
        model = Barlow.load_from_checkpoint(checkpoint_path=config_dict_["ckpt_in"], strict=False)
    elif ssl_model == "dino":
        model = Dino.load_from_checkpoint(checkpoint_path=config_dict_["ckpt_in"], strict=False)
    elif ssl_model == "simclr":
        model = Simclr.load_from_checkpoint(checkpoint_path=config_dict_["ckpt_in"], strict=False)
    elif ssl_model == "vae":
        model = Vae.load_from_checkpoint(checkpoint_path=config_dict_["ckpt_in"], strict=False)
    else:
        raise Exception("ssl_model should be either barlow, dino, simclr, vae. Received {0}".format(ssl_model))

    # load anndata and convert to sparse_img
    anndata = read_h5ad(config_dict_["anndata_in"])
    dm = AnndataFolderDM(**model._hparams)
    sparse_img = dm.anndata_to_sparseimage(anndata=anndata)
    if config_dict_["gpu_enabled"]:
        sparse_img = sparse_img.cuda()
        model = model.cuda()
    else:
        sparse_img = sparse_img.cpu()
        model = model.cpu()

    # compute simple ncv
    if config_dict_["ncv_k"] is not None:
        for k in config_dict_["ncv_k"]:
            sparse_img.compute_ncv(feature_name="ncv_k{}".format(k), k=k)
    if config_dict_["ncv_r"] is not None:
        for r in config_dict_["ncv_r"]:
            sparse_img.compute_ncv(feature_name="ncv_r{}".format(r), r=r)

    # compute the ssl features
    sparse_img.compute_patch_features(
        feature_name=config_dict_["feature_key"],
        model=model,
        datamodule=dm,
        batch_size=64,
        n_patches_max=config_dict_["n_patches"],
        overwrite=True
    )
    sparse_img.transfer_patch_to_spot(keys_to_transfer=[config_dict_["feature_key"]],
                                      overwrite=True,
                                      verbose=False,
                                      strategy_patch_to_image=config_dict_["strategy_patch_to_image"],
                                      strategy_image_to_spot=config_dict_["strategy_image_to_spot"])

    # remove the intermediate results in the patch_dict and image_dict and save the new anndata to file
    sparse_img.clear(patch_dict=True, image_dict=True)
    new_anndata = sparse_img.to_anndata()
    new_anndata.write(filename=config_dict_["anndata_out"])
    print("written annotated anndata to file", config_dict_["anndata_out"])
